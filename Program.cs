using Microsoft.Data.SqlClient;
using Microsoft.SqlServer.Management.Common;
using Microsoft.SqlServer.Management.Sdk.Sfc;
using Microsoft.SqlServer.Management.Smo;
using System;
using System.Collections.Generic;
using System.CommandLine;
using System.ComponentModel.DataAnnotations;
using System.IO;
using System.Text;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

class Program
{
    public class ExportConfig
    {
        [Required]
        public string Host { get; set; } = "";

        public ushort Port { get; set; } = 1433;

        [Required]
        public string Database { get; set; } = "";

        public bool Encrypt { get; set; } = false;

        public bool TrustServerCertificate { get; set; } = true;

        public int ConnectTimeout { get; set; } = 10;

        [Required]
        public string User { get; set; } = "";

        [Required]
        public string Password { get; set; } = "";

        [Required]
        public Dictionary<string, List<string>> Tables { get; set; } = [];
    }

    public class ImportConfig
    {
        [Required]
        public string Host { get; set; } = "";

        public ushort Port { get; set; } = 1433;

        [Required]
        public string Database { get; set; } = "";

        public bool Encrypt { get; set; } = false;

        public bool TrustServerCertificate { get; set; } = true;

        public int ConnectTimeout { get; set; } = 10;

        [Required]
        public string User { get; set; } = "";

        [Required]
        public string Password { get; set; } = "";
    }

    static int Main(string[] args)
    {
        RootCommand rootCommand = new("harbor: export/import MSSQL database schema")
        {
            TreatUnmatchedTokensAsErrors = true,
        };

        Option<FileInfo> configFileOption = new("--config", "-c")
        {
            Description = "Config file path",
            Required = true,
            AllowMultipleArgumentsPerToken = false,
        };
        configFileOption.AcceptExistingOnly();

        var exportCommand = new Command("export", "Exports database schema to stdout")
        {
            configFileOption
        };
        exportCommand.Aliases.Add("dump");
        exportCommand.SetAction(parseResult =>
        {
            var configFile = parseResult.GetRequiredValue(configFileOption);
            return Export(configFile);
        });
        rootCommand.Subcommands.Add(exportCommand);

        Argument<FileInfo> importScriptArgument = new("script")
        {
            Description = "Path to the SQL schema script file to import",
            Arity = ArgumentArity.ExactlyOne,
        };
        importScriptArgument.AcceptExistingOnly();

        var importCommand = new Command("import", "Imports schema from a SQL script file generated by the export command")
        {
            configFileOption,
        };
        importCommand.Aliases.Add("load");
        importCommand.Arguments.Add(importScriptArgument);
        importCommand.SetAction(parseResult =>
        {
            var configFile = parseResult.GetRequiredValue(configFileOption);
            var scriptFile = parseResult.GetRequiredValue(importScriptArgument);
            return Import(configFile, scriptFile);
        });
        rootCommand.Subcommands.Add(importCommand);

        return rootCommand.Parse(args).Invoke();
    }

    internal static int Export(FileInfo configFile)
    {
        Console.WriteLine("üì§ Exporting schema to schema.sql...");

        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .WithEnforceRequiredMembers()
            .Build();

        var config = deserializer.Deserialize<ExportConfig>(File.ReadAllText(configFile.FullName));

        if (config.Tables.Count == 0)
        {
            Console.WriteLine("‚ùå No tables specified in configuration.");
            return 1;
        }

        Console.WriteLine($"üîå Connecting to {config.Host}:{config.Port} as {config.User}...");
        var conn = new ServerConnection($"{config.Host},{config.Port}", config.User, config.Password)
        {
            ApplicationIntent = "ReadOnly",
            ApplicationName = "harbor",
            ConnectTimeout = config.ConnectTimeout,
            DatabaseName = config.Database,
            EncryptConnection = config.Encrypt,
            TrustServerCertificate = config.TrustServerCertificate,
        };

        var server = new Server(conn);
        var db = server.Databases[config.Database];
        if (db == null)
        {
            Console.WriteLine($"Database '{config.Database}' not found!");
            return 1;
        }

        List<Urn> tableUrns = [];
        foreach (var (schema, tableNames) in config.Tables)
        {
            foreach (var tableName in tableNames)
            {
                var table = db.Tables[tableName, schema];
                if (table == null)
                {
                    Console.WriteLine($"‚ö†Ô∏è Table '[{schema}].[{tableName}]' not found, skipping.");
                    continue;
                }

                Console.WriteLine($"üìù Queued table [{schema}].[{tableName}]");
                tableUrns.Add(table.Urn);
            }
        }

        if (tableUrns.Count == 0)
        {
            Console.WriteLine("‚ùå No valid tables found to script.");
            return 1;
        }

        var scripter = new Scripter(server)
        {
            Options = {
                ClusteredIndexes = true,
                ContinueScriptingOnError = false,
                DriAll = true,
                Encoding = Encoding.UTF8,
                IncludeHeaders = false,
                IncludeIfNotExists = false,
                Indexes = true,
                NonClusteredIndexes = true,
                Permissions = false,
                SchemaQualify = true,
                ScriptBatchTerminator = true,
                ScriptData = false,
                ScriptSchema = true,
                ToFileOnly = true,
                FileName = "schema.sql",
            },
        };

        var lines = scripter.Script(tableUrns.ToArray());
        foreach (string line in lines)
        {
            Console.Out.WriteLine(line);
            Console.Out.WriteLine("\n");
        }

        Console.WriteLine("‚úÖ Schema scripting complete.");

        return 0;
    }

    internal static int Import(FileInfo configFile, FileInfo scriptFile)
    {
        Console.WriteLine($"üì• Importing schema from script {scriptFile.Name}...");

        var deserializer = new DeserializerBuilder()
            .WithNamingConvention(UnderscoredNamingConvention.Instance)
            .WithEnforceRequiredMembers()
            .Build();

        var config = deserializer.Deserialize<ImportConfig>(File.ReadAllText(configFile.FullName));

        Console.WriteLine($"üîå Connecting to server {config.Host}:{config.Port} as {config.User}...");

        var masterConnBuilder = new SqlConnectionStringBuilder
        {
            ConnectTimeout = config.ConnectTimeout,
            DataSource = $"{config.Host},{config.Port}",
            Encrypt = config.Encrypt,
            InitialCatalog = "master",
            Password = config.Password,
            TrustServerCertificate = config.TrustServerCertificate,
            UserID = config.User,
        };

        using (var conn = new SqlConnection(masterConnBuilder.ConnectionString))
        {
            conn.Open();
            var server = new Server(new ServerConnection(conn));
            if (server.Databases.Contains(config.Database))
            {
                Console.WriteLine($"‚ö†Ô∏è Dropping existing database '{config.Database}'...");
                server.KillDatabase(config.Database);
            }

            Console.WriteLine($"üß± Creating new database '{config.Database}'...");
            var db = new Database(server, config.Database);
            db.Create();
        }

        var dbConnBuilder = new SqlConnectionStringBuilder
        {
            ConnectTimeout = config.ConnectTimeout,
            DataSource = $"{config.Host},{config.Port}",
            Encrypt = config.Encrypt,
            InitialCatalog = config.Database,
            Password = config.Password,
            TrustServerCertificate = config.TrustServerCertificate,
            UserID = config.User,
        };

        using (var conn = new SqlConnection(dbConnBuilder.ConnectionString))
        {
            conn.Open();
            var server = new Server(new ServerConnection(conn));
            var script = File.ReadAllText(scriptFile.FullName);
            server.ConnectionContext.ExecuteNonQuery(script);
        }

        return 0;
    }
}
